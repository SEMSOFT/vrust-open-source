{
  "id": "VRust",
  "user": "O2Lab VRust Team",
  "crate": "bridge",
  "git-loc": "https://github.com/parasol-aser/vrust",
  "timestamp": "1648156913",
  "int_cnt": 5,
  "chk_cnt": 1,
  "typ_cnt": 0,
  "oth_cnt": 0,
  "total": 6,
  "errors": [
    {
      "id": "0",
      "category": "IntegerFlow",
      "severity": "Critical",
      "location": "api::verify_signature::verify_signatures",
      "code": "program/src/api/verify_signature.rs:100:25: 100:50 \n\t(current_instruction - 1)",
      "context": "program/src/api/verify_signature.rs:68:1: 219:2 \n\tpub fn verify_signatures(\n    ctx: &ExecutionContext,\n    accs: &mut VerifySignatures,\n    data: VerifySignaturesData,\n) -> Result<()> {\n    accs.guardian_set\n        .verify_derivation(ctx.program_id, &(&*accs).into())?;\n\n    let sig_infos: Vec<SigInfo> = data\n        .signers\n        .iter()\n        .enumerate()\n        .filter_map(|(i, p)| {\n            if *p == -1 {\n                return None;\n            }\n\n            return Some(SigInfo {\n                sig_index: *p as u8,\n                signer_index: i as u8,\n            });\n        })\n        .collect();\n\n    let current_instruction = solana_program::sysvar::instructions::load_current_index_checked(\n        &accs.instruction_acc,\n    )?;\n    if current_instruction == 0 {\n        return Err(InstructionAtWrongIndex.into());\n    }\n\n    // The previous ix must be a secp verification instruction\n    let secp_ix_index = (current_instruction - 1) as u8;\n    let secp_ix = solana_program::sysvar::instructions::load_instruction_at_checked(\n        secp_ix_index as usize,\n        &accs.instruction_acc,\n    )\n    .map_err(|_| ProgramError::InvalidAccountData)?;\n\n    // Check that the instruction is actually for the secp program\n    if secp_ix.program_id != solana_program::secp256k1_program::id() {\n        return Err(InvalidSecpInstruction.into());\n    }\n\n    let secp_data_len = secp_ix.data.len();\n    if secp_data_len < 2 {\n        return Err(InvalidSecpInstruction.into());\n    }\n\n    let sig_len = secp_ix.data[0];\n    let mut index = 1;\n\n    let mut secp_ixs: Vec<SecpInstructionPart> = Vec::with_capacity(sig_len as usize);\n    for i in 0..sig_len {\n        let _sig_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n        index += 2;\n        let sig_ix = secp_ix.data[index];\n        index += 1;\n        let address_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]) as usize;\n        index += 2;\n        let address_ix = secp_ix.data[index];\n        index += 1;\n        let msg_offset = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n        index += 2;\n        let msg_size = byteorder::LE::read_u16(&secp_ix.data[index..index + 2]);\n        index += 2;\n        let msg_ix = secp_ix.data[index];\n        index += 1;\n\n        if address_ix != secp_ix_index || msg_ix != secp_ix_index || sig_ix != secp_ix_index {\n            return Err(InvalidSecpInstruction.into());\n        }\n\n        let address: &[u8] = &secp_ix.data[address_offset..address_offset + 20];\n\n        // Make sure that all messages are equal\n        if i > 0 {\n            if msg_offset != secp_ixs[0].msg_offset || msg_size != secp_ixs[0].msg_size {\n                return Err(InvalidSecpInstruction.into());\n            }\n        }\n        secp_ixs.push(SecpInstructionPart {\n            address,\n            msg_offset,\n            msg_size,\n        });\n    }\n\n    if sig_infos.len() != secp_ixs.len() {\n        return Err(ProgramError::InvalidArgument.into());\n    }\n\n    // Data must be a hash\n    if secp_ixs[0].msg_size != 32 {\n        return Err(ProgramError::InvalidArgument.into());\n    }\n\n    // Extract message which is encoded in Solana Secp256k1 instruction data.\n    let message = &secp_ix.data\n        [secp_ixs[0].msg_offset as usize..(secp_ixs[0].msg_offset + secp_ixs[0].msg_size) as usize];\n\n    // Hash the message part, which contains the serialized VAA body.\n    let mut msg_hash: [u8; 32] = [0u8; 32];\n    msg_hash.copy_from_slice(message);\n\n    if !accs.signature_set.is_initialized() {\n        accs.signature_set.signatures = vec![false; accs.guardian_set.keys.len()];\n        accs.signature_set.guardian_set_index = accs.guardian_set.index;\n        accs.signature_set.hash = msg_hash;\n\n        let size = accs.signature_set.size();\n        let ix = solana_program::system_instruction::create_account(\n            accs.payer.key,\n            accs.signature_set.info().key,\n            Exempt.amount(size),\n            size as u64,\n            ctx.program_id,\n        );\n        solana_program::program::invoke(&ix, ctx.accounts)?;\n    } else {\n        // If the account already existed, check that the parameters match\n        if accs.signature_set.guardian_set_index != accs.guardian_set.index {\n            return Err(GuardianSetMismatch.into());\n        }\n\n        if accs.signature_set.hash != msg_hash {\n            return Err(InvalidHash.into());\n        }\n    }\n\n    // Write sigs of checked addresses into sig_state\n    for s in sig_infos {\n        if s.signer_index > accs.guardian_set.num_guardians() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n\n        if s.sig_index + 1 > sig_len {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n\n        let key = accs.guardian_set.keys[s.signer_index as usize];\n        // Check key in ix\n        if key != secp_ixs[s.sig_index as usize].address {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n\n        // Overwritten content should be zeros except double signs by the signer or harmless replays\n        accs.signature_set.signatures[s.signer_index as usize] = true;\n    }\n\n    Ok(())\n}",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::VerifySignatures::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn api::verify_signature::verify_signatures(){// program/src/api/verify_signature.rs:68:1: 219:2 }\n",
      "status": "UnResolved",
      "description": "A mild bug. This int overflow involves a function call to ```let current_instruction = solana_program::sysvar::instructions::load_current_index_checked(\n      &accs.instruction_acc,\n  )?;\n (https://docs.rs/solana-program/1.9.1/solana_program/sysvar/instructions/fn.load_current_index_checked.html): Load the current Instructionâ€™s index in the currently executing Transaction. (Constrain: current_instruction>=0 (not general enough to model)). And it has a check at line 95: current_instruction != 0 (this could be modeled into the overflow checker.)\n ",
      "link": "",
      "alleviation": "Checker could be updated for  `x - 1` and a check on `x == 0` or `x >= 0`, add constrains handling. (Needs a solver to handle the case where the instruction is `current_instruction - 5` or `x - y (a variable)`.)"
    },
    {
      "id": "1",
      "category": "IntegerFlow",
      "severity": "Critical",
      "location": "solana_program::message::Message::deserialize_instruction",
      "code": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:466:20: 466:29 \n\tindex * 2",
      "context": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:455:5: 497:6 \n\tpub fn deserialize_instruction(\n        index: usize,\n        data: &[u8],\n    ) -> Result<Instruction, SanitizeError> {\n        let mut current = 0;\n        let num_instructions = read_u16(&mut current, data)?;\n        if index >= num_instructions as usize {\n            return Err(SanitizeError::IndexOutOfBounds);\n        }\n\n        // index into the instruction byte-offset table.\n        current += index * 2;\n        let start = read_u16(&mut current, data)?;\n\n        current = start as usize;\n        let num_accounts = read_u16(&mut current, data)?;\n        let mut accounts = Vec::with_capacity(num_accounts as usize);\n        for _ in 0..num_accounts {\n            let meta_byte = read_u8(&mut current, data)?;\n            let mut is_signer = false;\n            let mut is_writable = false;\n            if meta_byte & (1 << Self::IS_SIGNER_BIT) != 0 {\n                is_signer = true;\n            }\n            if meta_byte & (1 << Self::IS_WRITABLE_BIT) != 0 {\n                is_writable = true;\n            }\n            let pubkey = read_pubkey(&mut current, data)?;\n            accounts.push(AccountMeta {\n                pubkey,\n                is_signer,\n                is_writable,\n            });\n        }\n        let program_id = read_pubkey(&mut current, data)?;\n        let data_len = read_u16(&mut current, data)?;\n        let data = read_slice(&mut current, data, data_len as usize)?;\n        Ok(Instruction {\n            program_id,\n            accounts,\n            data,\n        })\n    }",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::VerifySignatures::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn api::verify_signature::verify_signatures(){// program/src/api/verify_signature.rs:68:1: 219:2 }\n\t\t\t\t\tfn solana_program::sysvar::instructions::load_instruction_at_checked(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/sysvar/instructions.rs:71:1: 86:2 }\n\t\t\t\t\t\tfn solana_program::message::Message::deserialize_instruction(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:455:5: 497:6 }\n",
      "status": "UnResolved",
      "description": "Built-in library for instruction serialization and `deserialize_instruction`.  ",
      "link": "",
      "alleviation": "Not a real bug. The parameter `index` is calculated as `secp_ix_index` from `solana_program::sysvar::instructions::load_current_index_checked`. Another argument is an external argument (can be fake). However, the `instruction id` variable is also with a check on `if index >= num_instructions as usize ` (Line 461 in the report), and therefore, it is hard to reason about the value of the condition to revise the checker."
    },
    {
      "id": "2",
      "category": "IntegerFlow",
      "severity": "Critical",
      "location": "solana_program::serialize_utils::read_u8",
      "code": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:25:21: 25:33 \n\t*current + 1",
      "context": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:24:1: 31:2 \n\tpub fn read_u8(current: &mut usize, data: &[u8]) -> Result<u8, SanitizeError> {\n    if data.len() < *current + 1 {\n        return Err(SanitizeError::IndexOutOfBounds);\n    }\n    let e = data[*current];\n    *current += 1;\n    Ok(e)\n}",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::VerifySignatures::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn api::verify_signature::verify_signatures(){// program/src/api/verify_signature.rs:68:1: 219:2 }\n\t\t\t\t\tfn solana_program::sysvar::instructions::load_instruction_at_checked(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/sysvar/instructions.rs:71:1: 86:2 }\n\t\t\t\t\t\tfn solana_program::message::Message::deserialize_instruction(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:455:5: 497:6 }\nfn solana_program::serialize_utils::read_u8(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:24:1: 31:2 }\n",
      "status": "UnResolved",
      "description": "Not real. There is a check in function deserialize_instruction (line 461): `if index >= num_instructions as usize {\n        return Err(SanitizeError::IndexOutOfBounds); \n    }`, and it limit the size of `index`. The `current` variable is calculated based on index and a &[u8] data.",
      "link": "",
      "alleviation": "This is not a general filter. It might filter out real bug. Also, it is a built in function in solana program. We should focus more on the correct use and not using the deprecated function in SPL (as the case in wormhole verify_signature)."
    },
    {
      "id": "3",
      "category": "IntegerFlow",
      "severity": "Critical",
      "location": "solana_program::serialize_utils::read_pubkey",
      "code": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:35:21: 35:35 \n\t*current + len",
      "context": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:33:1: 41:2 \n\tpub fn read_pubkey(current: &mut usize, data: &[u8]) -> Result<Pubkey, SanitizeError> {\n    let len = std::mem::size_of::<Pubkey>();\n    if data.len() < *current + len {\n        return Err(SanitizeError::IndexOutOfBounds);\n    }\n    let e = Pubkey::new(&data[*current..*current + len]);\n    *current += len;\n    Ok(e)\n}",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::VerifySignatures::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn api::verify_signature::verify_signatures(){// program/src/api/verify_signature.rs:68:1: 219:2 }\n\t\t\t\t\tfn solana_program::sysvar::instructions::load_instruction_at_checked(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/sysvar/instructions.rs:71:1: 86:2 }\n\t\t\t\t\t\tfn solana_program::message::Message::deserialize_instruction(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:455:5: 497:6 }\nfn solana_program::serialize_utils::read_pubkey(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:33:1: 41:2 }\n",
      "status": "UnResolved",
      "description": "Similar to ID 2",
      "link": "",
      "alleviation": "Similar to ID 2"
    },
    {
      "id": "4",
      "category": "IntegerFlow",
      "severity": "Critical",
      "location": "solana_program::serialize_utils::read_slice",
      "code": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:59:21: 59:40 \n\t*current + data_len",
      "context": "/home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:54:1: 65:2 \n\tpub fn read_slice(\n    current: &mut usize,\n    data: &[u8],\n    data_len: usize,\n) -> Result<Vec<u8>, SanitizeError> {\n    if data.len() < *current + data_len {\n        return Err(SanitizeError::IndexOutOfBounds);\n    }\n    let e = data[*current..*current + data_len].to_vec();\n    *current += data_len;\n    Ok(e)\n}",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::VerifySignatures::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn api::verify_signature::verify_signatures(){// program/src/api/verify_signature.rs:68:1: 219:2 }\n\t\t\t\t\tfn solana_program::sysvar::instructions::load_instruction_at_checked(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/sysvar/instructions.rs:71:1: 86:2 }\n\t\t\t\t\t\tfn solana_program::message::Message::deserialize_instruction(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/message/legacy.rs:455:5: 497:6 }\nfn solana_program::serialize_utils::read_slice(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/serialize_utils.rs:54:1: 65:2 }\n",
      "status": "UnResolved",
      "description": "Similar to ID 2",
      "link": "",
      "alleviation": "Not relevant to this case, but some new heuristics: we could develop something to filter out overflow that on the LHS of \"<\" and RHS of \"<\", or underflow on the RHS of \"<\" and LHS of \">\" with an error reported afterward (if the added number is small, therefore, the result is small enough to trigger the error). For example: if x + 1 < y {\n        return Err(SanitizeError::IndexOutOfBounds);\n    }, if x+1 may overflow, it will trigger the error."
    },
    {
      "id": "5",
      "category": "MissingKeyCheck",
      "severity": "Critical",
      "location": "<solitaire::Data<'b, T, IsInitialized> as solitaire::Peel<'a, 'b, 'c>>::peel",
      "code": "/home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/processors/peel.rs:214:52: 214:80 \n\tctx.info().data.borrow_mut()",
      "context": "/home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/processors/peel.rs:192:5: 236:6 \n\tfn peel<I>(ctx: &'c mut Context<'a, 'b, 'c, I>) -> Result<Self> {\n        if ctx.immutable && ctx.info().is_writable {\n            return Err(\n                SolitaireError::InvalidMutability(*ctx.info().key, ctx.info().is_writable).into(),\n            );\n        }\n\n        // If we're initializing the type, we should emit system/rent as deps.\n        let (initialized, data): (bool, T) = match IsInitialized {\n            AccountState::Uninitialized => {\n                if **ctx.info().lamports.borrow() != 0 {\n                    return Err(SolitaireError::AlreadyInitialized(*ctx.info().key));\n                }\n                (false, T::default())\n            }\n            AccountState::Initialized => {\n                (true, T::try_from_slice(&mut *ctx.info().data.borrow_mut())?)\n            }\n            AccountState::MaybeInitialized => {\n                if **ctx.info().lamports.borrow() == 0 {\n                    (false, T::default())\n                } else {\n                    (true, T::try_from_slice(&mut *ctx.info().data.borrow_mut())?)\n                }\n            }\n        };\n\n        if initialized {\n            match data.owner() {\n                AccountOwner::This => {\n                    if ctx.info().owner != ctx.this {\n                        return Err(SolitaireError::InvalidOwner(*ctx.info().owner));\n                    }\n                }\n                AccountOwner::Other(v) => {\n                    if *ctx.info().owner != v {\n                        return Err(SolitaireError::InvalidOwner(*ctx.info().owner));\n                    }\n                }\n                AccountOwner::Any => {}\n            };\n        }\n\n        Ok(Data(Box::new(ctx.info().clone()), data))\n    }",
      "callstack": "fn entrypoint(){// /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/solana-program-1.9.4/src/entrypoint.rs:120:9: 127:10 }\n\tfn instruction::solitaire(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:101:13: 108:14 }\n\t\tfn instruction::dispatch(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:89:13: 99:14 }\n\t\t\tfn instruction::PostVAA::execute(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/macros.rs:68:21: 74:22 }\n\t\t\t\tfn <api::post_vaa::PostVAA<'b> as solitaire::FromAccounts<'a, 'b, 'c>>::from(){// program/src/api/post_vaa.rs:54:10: 54:22 }\n\t\t\t\t\tfn <solitaire::Data<'b, T, IsInitialized> as solitaire::Peel<'a, 'b, 'c>>::peel(){// /home/ubuntu/VRust/wormhole/wormhole-2.7.3/solana/solitaire/program/src/processors/peel.rs:192:5: 236:6 }\n",
      "status": "UnResolved",
      "description": "It does have `ctx.info().data.borrow_mut`, but no transaction involved.",
      "link": "",
      "alleviation": "We could prioritize the bug reported with a transaction, transfer, or any other critical functions involved to find the more serious bugs."
    }
  ]
}