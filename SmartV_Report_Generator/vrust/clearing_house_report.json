{
    "id": "VRust",
    "user": "O2Lab VRust Team",
    "crate": "clearing_house",
    "git-loc": "https://github.com/parasol-aser/vrust",
    "timestamp": "1644095938",
    "errors": [
      {
        "type": "IntegerCve",
        "id": "INT_CVE_0",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "__private::__idl::__idl_create_account",
        "code": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "context": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "callstack": "programs/clearing_house/src/lib.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_1",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "__private::__idl::__idl_create_account",
        "code": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "context": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "callstack": "programs/clearing_house/src/lib.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_2",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "__private::__idl::__idl_create_account",
        "code": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "context": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "callstack": "programs/clearing_house/src/lib.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_0",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:313:10: 313:18 \n\tAccounts",
        "callstack": "<instructions::OpenPosition<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::OpenPosition<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_1",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:78:10: 78:18 \n\tAccounts",
        "callstack": "<instructions::InitializeUser<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::InitializeUser<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_2",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:230:10: 230:18 \n\tAccounts",
        "callstack": "<instructions::WithdrawFees<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::WithdrawFees<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_3",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::full_shr",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:834:31: 834:63 \n\t(Self::WORD_BITS as u32 - shift)",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:825:4: 838:5 \n\tfn full_shr(u: [u64; $n_words + 1], shift: u32) -> Self {\n\t\t\t\tdebug_assert!(shift < Self::WORD_BITS as u32);\n\t\t\t\tlet mut res = Self::zero();\n\t\t\t\tfor i in 0..$n_words {\n\t\t\t\t\tres.0[i] = u[i] >> shift;\n\t\t\t\t}\n\t\t\t\t// carry\n\t\t\t\tif shift > 0 {\n\t\t\t\t\tfor i in 1..=$n_words {\n\t\t\t\t\t\tres.0[i - 1] |= u[i] << (Self::WORD_BITS as u32 - shift);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_3",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:137:10: 137:18 \n\tAccounts",
        "callstack": "<instructions::DepositCollateral<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::DepositCollateral<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_4",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::full_shl",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:819:24: 819:56 \n\t(Self::WORD_BITS as u32 - shift)",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:815:4: 823:5 \n\tfn full_shl(self, shift: u32) -> [u64; $n_words + 1] {\n\t\t\t\tdebug_assert!(shift < Self::WORD_BITS as u32);\n\t\t\t\tlet mut u = [0u64; $n_words + 1];\n\t\t\t\tlet u_lo = self.0[0] << shift;\n\t\t\t\tlet u_hi = self >> (Self::WORD_BITS as u32 - shift);\n\t\t\t\tu[0] = u_lo;\n\t\t\t\tu[1..].copy_from_slice(&u_hi.0[..]);\n\t\t\t\tu\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_4",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:391:10: 391:18 \n\tAccounts",
        "callstack": "<instructions::Liquidate<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::Liquidate<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_5",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:13:10: 13:18 \n\tAccounts",
        "callstack": "<instructions::Initialize<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::Initialize<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_6",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:536:10: 536:18 \n\tAccounts",
        "callstack": "<instructions::AdminUpdateK<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::AdminUpdateK<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_5",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::full_shr",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:834:31: 834:63 \n\t(Self::WORD_BITS as u32 - shift)",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:825:4: 838:5 \n\tfn full_shr(u: [u64; $n_words + 1], shift: u32) -> Self {\n\t\t\t\tdebug_assert!(shift < Self::WORD_BITS as u32);\n\t\t\t\tlet mut res = Self::zero();\n\t\t\t\tfor i in 0..$n_words {\n\t\t\t\t\tres.0[i] = u[i] >> shift;\n\t\t\t\t}\n\t\t\t\t// carry\n\t\t\t\tif shift > 0 {\n\t\t\t\t\tfor i in 1..=$n_words {\n\t\t\t\t\t\tres.0[i - 1] |= u[i] << (Self::WORD_BITS as u32 - shift);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_6",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::full_shl",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:819:24: 819:56 \n\t(Self::WORD_BITS as u32 - shift)",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:815:4: 823:5 \n\tfn full_shl(self, shift: u32) -> [u64; $n_words + 1] {\n\t\t\t\tdebug_assert!(shift < Self::WORD_BITS as u32);\n\t\t\t\tlet mut u = [0u64; $n_words + 1];\n\t\t\t\tlet u_lo = self.0[0] << shift;\n\t\t\t\tlet u_hi = self >> (Self::WORD_BITS as u32 - shift);\n\t\t\t\tu[0] = u_lo;\n\t\t\t\tu[1..].copy_from_slice(&u_hi.0[..]);\n\t\t\t\tu\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_7",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::mul_u64",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1250:37: 1250:58 \n\ta as u128 * b as u128",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1249:4: 1252:5 \n\tconst fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {\n\t\t\t\tlet (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);\n\t\t\t\t(lo, hi)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_8",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::mul_u64",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1250:37: 1250:74 \n\ta as u128 * b as u128 + carry as u128",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1249:4: 1252:5 \n\tconst fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {\n\t\t\t\tlet (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);\n\t\t\t\t(lo, hi)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_9",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:879:19: 879:24 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_10",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:887:63: 887:68 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_11",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:892:33: 892:38 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_12",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:928:20: 928:25 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_13",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U192::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:928:9: 928:14 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_7",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:122:10: 122:18 \n\tAccounts",
        "callstack": "<instructions::InitializeMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::InitializeMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_14",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::mul_u64",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1250:37: 1250:58 \n\ta as u128 * b as u128",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1249:4: 1252:5 \n\tconst fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {\n\t\t\t\tlet (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);\n\t\t\t\t(lo, hi)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_15",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::mul_u64",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1250:37: 1250:74 \n\ta as u128 * b as u128 + carry as u128",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:1249:4: 1252:5 \n\tconst fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {\n\t\t\t\tlet (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);\n\t\t\t\t(lo, hi)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_16",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:879:19: 879:24 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_17",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:887:63: 887:68 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_18",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:892:33: 892:38 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_19",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:928:20: 928:25 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_20",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "math::bn::U256::div_mod_knuth",
        "code": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:928:9: 928:14 \n\tj + n",
        "context": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs:859:4: 939:5 \n\tfn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {\n\t\t\t\tdebug_assert!(self.bits() >= v.bits() && !v.fits_word());\n\t\t\t\tdebug_assert!(n + m <= $n_words);\n\t\t\t\t// D1.\n\t\t\t\t// Make sure 64th bit in v's highest word is set.\n\t\t\t\t// If we shift both self and v, it won't affect the quotient\n\t\t\t\t// and the remainder will only need to be shifted back.\n\t\t\t\tlet shift = v.0[n - 1].leading_zeros();\n\t\t\t\tv <<= shift;\n\t\t\t\t// u will store the remainder (shifted)\n\t\t\t\tlet mut u = self.full_shl(shift);\n\n\t\t\t\t// quotient\n\t\t\t\tlet mut q = Self::zero();\n\t\t\t\tlet v_n_1 = v.0[n - 1];\n\t\t\t\tlet v_n_2 = v.0[n - 2];\n\n\t\t\t\t// D2. D7.\n\t\t\t\t// iterate from m downto 0\n\t\t\t\tfor j in (0..=m).rev() {\n\t\t\t\t\tlet u_jn = u[j + n];\n\n\t\t\t\t\t// D3.\n\t\t\t\t\t// q_hat is our guess for the j-th quotient digit\n\t\t\t\t\t// q_hat = min(b - 1, (u_{j+n} * b + u_{j+n-1}) / v_{n-1})\n\t\t\t\t\t// b = 1 << WORD_BITS\n\t\t\t\t\t// Theorem B: q_hat >= q_j >= q_hat - 2\n\t\t\t\t\tlet mut q_hat = if u_jn < v_n_1 {\n\t\t\t\t\t\tlet (mut q_hat, mut r_hat) = Self::div_mod_word(u_jn, u[j + n - 1], v_n_1);\n\t\t\t\t\t\t// this loop takes at most 2 iterations\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\t// check if q_hat * v_{n-2} > b * r_hat + u_{j+n-2}\n\t\t\t\t\t\t\tlet (hi, lo) = Self::split_u128(u128::from(q_hat) * u128::from(v_n_2));\n\t\t\t\t\t\t\tif (hi, lo) <= (r_hat, u[j + n - 2]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// then iterate till it doesn't hold\n\t\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t\tlet (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);\n\t\t\t\t\t\t\tr_hat = new_r_hat;\n\t\t\t\t\t\t\t// if r_hat overflowed, we're done\n\t\t\t\t\t\t\tif overflow {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq_hat\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// here q_hat >= q_j >= q_hat - 1\n\t\t\t\t\t\tu64::max_value()\n\t\t\t\t\t};\n\n\t\t\t\t\t// ex. 20:\n\t\t\t\t\t// since q_hat * v_{n-2} <= b * r_hat + u_{j+n-2},\n\t\t\t\t\t// either q_hat == q_j, or q_hat == q_j + 1\n\n\t\t\t\t\t// D4.\n\t\t\t\t\t// let's assume optimistically q_hat == q_j\n\t\t\t\t\t// subtract (q_hat * v) from u[j..]\n\t\t\t\t\tlet q_hat_v = v.full_mul_u64(q_hat);\n\t\t\t\t\t// u[j..] -= q_hat_v;\n\t\t\t\t\tlet c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);\n\n\t\t\t\t\t// D6.\n\t\t\t\t\t// actually, q_hat == q_j + 1 and u[j..] has overflowed\n\t\t\t\t\t// highly unlikely ~ (1 / 2^63)\n\t\t\t\t\tif c {\n\t\t\t\t\t\tq_hat -= 1;\n\t\t\t\t\t\t// add v to u[j..]\n\t\t\t\t\t\tlet c = Self::add_slice(&mut u[j..], &v.0[..n]);\n\t\t\t\t\t\tu[j + n] = u[j + n].wrapping_add(u64::from(c));\n\t\t\t\t\t}\n\n\t\t\t\t\t// D5.\n\t\t\t\t\tq.0[j] = q_hat;\n\t\t\t\t}\n\n\t\t\t\t// D8.\n\t\t\t\tlet remainder = Self::full_shr(u, shift);\n\n\t\t\t\t(q, remainder)\n\t\t\t}",
        "callstack": "/home/tien/.cargo/registry/src/github.com-1ecc6299db9ec823/uint-0.9.1/src/uint.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_8",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:99:10: 99:18 \n\tAccounts",
        "callstack": "<instructions::DeleteUser<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::DeleteUser<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_9",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:277:10: 277:18 \n\tAccounts",
        "callstack": "<instructions::WithdrawFromInsuranceVaultToMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::WithdrawFromInsuranceVaultToMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_10",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:177:10: 177:18 \n\tAccounts",
        "callstack": "<instructions::WithdrawCollateral<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::WithdrawCollateral<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_11",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:256:10: 256:18 \n\tAccounts",
        "callstack": "<instructions::WithdrawFromInsuranceVault<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::WithdrawFromInsuranceVault<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "IntegerCve",
        "id": "INT_CVE_21",
        "title": "Overflow",
        "category": "Integer Overflow",
        "severity": "Critical",
        "location": "__private::__idl::__idl_create_account",
        "code": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "context": "programs/clearing_house/src/lib.rs:27:1: 27:11 \n\t#[program]",
        "callstack": "programs/clearing_house/src/lib.rs",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_12",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:511:10: 511:18 \n\tAccounts",
        "callstack": "<instructions::MoveAMMPrice<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::MoveAMMPrice<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_13",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:526:10: 526:18 \n\tAccounts",
        "callstack": "<instructions::AdminUpdateState<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::AdminUpdateState<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_14",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:552:10: 552:18 \n\tAccounts",
        "callstack": "<instructions::AdminUpdateMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::AdminUpdateMarket<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_15",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:56:10: 56:18 \n\tAccounts",
        "callstack": "<instructions::InitializeHistory<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::InitializeHistory<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_16",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:491:10: 491:18 \n\tAccounts",
        "callstack": "<instructions::RepegCurve<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::RepegCurve<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_17",
        "title": "is_signer",
        "category": "Captured Signer Check",
        "severity": "Informational",
        "location": "programs/clearing_house/src/instructions.rs",
        "code": "programs/clearing_house/src/instructions.rs:352:10: 352:18 \n\tAccounts",
        "callstack": "<instructions::ClosePosition<'info> as anchor_lang::Accounts<'info>>::try_accounts",
        "status": "Resolved",
        "description": "Captured is_signer check for function: <instructions::ClosePosition<'info> as anchor_lang::Accounts<'info>>::try_accounts\nWe captured an is_signer check for variable: <anchor_lang::Signer as anchor_lang::Accounts>::try_accounts",
        "link": "https://github.com/parasol-aser/vrust/blob/yifei/patterns/01/README.md",
        "alleviation": "Nothing needs to be done."
      }
    ]
  }