{
    "id": "VRust",
    "user": "O2Lab VRust Team",
    "crate": "mpl_metaplex",
    "git-loc": "https://github.com/parasol-aser/vrust",
    "timestamp": "1644004477",
    "errors": [
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_0",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/set_store_index.rs",
        "code": "metaplex/program/src/processor/set_store_index.rs:22:1: 217:2 \n\tpub fn process_set_store_index<'a>(\n    program_id: &'a Pubkey,\n    accounts: &'a [AccountInfo<'a>],\n    args: SetStoreIndexArgs,\n) -> ProgramResult {\n    let SetStoreIndexArgs { offset, page } = args;\n\n    let offset_u = offset as usize;\n\n    let account_info_iter = &mut accounts.iter();\n\n    let store_index_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let auction_cache_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let above_cache_info = next_account_info(account_info_iter).ok();\n    let below_cache_info = next_account_info(account_info_iter).ok();\n    let _store = Store::from_account_info(store_info)?;\n    let auction_cache = AuctionCache::from_account_info(auction_cache_info)?;\n\n    let mut below_cache: Option<AuctionCache> = None;\n    let mut above_cache: Option<AuctionCache> = None;\n\n    assert_signer(payer_info)?;\n    assert_owned_by(store_info, program_id)?;\n    assert_owned_by(auction_cache_info, program_id)?;\n\n    if system_info.key != &solana_program::system_program::id() {\n        return Err(MetaplexError::InvalidSystemProgram.into());\n    }\n\n    assert_derivation(\n        program_id,\n        auction_cache_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            auction_cache.auction.as_ref(),\n            CACHE.as_bytes(),\n        ],\n    )?;\n\n    if let Some(below) = below_cache_info {\n        let unwrapped = AuctionCache::from_account_info(below)?;\n\n        assert_derivation(\n            program_id,\n            below,\n            &[\n                PREFIX.as_bytes(),\n                program_id.as_ref(),\n                store_info.key.as_ref(),\n                unwrapped.auction.as_ref(),\n                CACHE.as_bytes(),\n            ],\n        )?;\n        assert_owned_by(below, program_id)?;\n\n        below_cache = Some(unwrapped);\n    }\n\n    if let Some(above) = &above_cache_info {\n        let unwrapped = AuctionCache::from_account_info(above)?;\n\n        assert_derivation(\n            program_id,\n            above,\n            &[\n                PREFIX.as_bytes(),\n                program_id.as_ref(),\n                store_info.key.as_ref(),\n                unwrapped.auction.as_ref(),\n                CACHE.as_bytes(),\n            ],\n        )?;\n        assert_owned_by(above, program_id)?;\n\n        above_cache = Some(unwrapped);\n    }\n\n    let as_string = page.to_string();\n    let bump = assert_derivation(\n        program_id,\n        store_index_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            INDEX.as_bytes(),\n            as_string.as_bytes(),\n        ],\n    )?;\n\n    if store_index_info.data_is_empty() {\n        let signer_seeds = &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            INDEX.as_bytes(),\n            as_string.as_bytes(),\n            &[bump],\n        ];\n\n        create_or_allocate_account_raw(\n            *program_id,\n            store_index_info,\n            rent_info,\n            system_info,\n            payer_info,\n            MAX_STORE_INDEXER_SIZE,\n            signer_seeds,\n        )?;\n    }\n\n    assert_owned_by(store_index_info, program_id)?;\n\n    let mut indexer = StoreIndexer::from_account_info(store_index_info)?;\n    indexer.key = Key::StoreIndexerV1;\n    indexer.store = *store_info.key;\n    indexer.page = page;\n\n    if offset_u > indexer.auction_caches.len() {\n        return Err(MetaplexError::InvalidCacheOffset.into());\n    }\n\n    if indexer.auction_caches.len() > 0 && offset_u < indexer.auction_caches.len() - 1 {\n        let above_key = &indexer.auction_caches[offset_u];\n        if let Some(abo) = &above_cache {\n            if let Some(above_cache_info_unwrapped) = above_cache_info {\n                if above_cache_info_unwrapped.key != above_key {\n                    return Err(MetaplexError::CacheMismatch.into());\n                } else if abo.timestamp > auction_cache.timestamp {\n                    return Err(MetaplexError::CacheAboveIsNewer.into());\n                }\n            } else {\n                msg!(\"Should never happen\");\n                return Err(MetaplexError::InvalidOperation.into());\n            }\n        } else {\n            return Err(MetaplexError::ExpectedAboveAuctionCacheToBeProvided.into());\n        }\n    }\n\n    if offset_u > 0 {\n        let below_key = &indexer.auction_caches[offset_u - 1];\n        // special case where you're at top of stack, there is no above\n        let cache_used_for_below = if offset_u == indexer.auction_caches.len() - 1 {\n            &above_cache\n        } else {\n            &below_cache\n        };\n\n        let cache_info_used_for_below = if offset_u == indexer.auction_caches.len() - 1 {\n            above_cache_info\n        } else {\n            below_cache_info\n        };\n\n        if let Some(bel) = cache_used_for_below {\n            if let Some(below_cache_info_unwrapped) = cache_info_used_for_below {\n                if below_cache_info_unwrapped.key != below_key {\n                    return Err(MetaplexError::CacheMismatch.into());\n                } else if bel.timestamp < auction_cache.timestamp {\n                    return Err(MetaplexError::CacheBelowIsOlder.into());\n                }\n            } else {\n                msg!(\"Should never happen\");\n                return Err(MetaplexError::InvalidOperation.into());\n            }\n        } else {\n            return Err(MetaplexError::ExpectedAboveAuctionCacheToBeProvided.into());\n        }\n    }\n\n    let mut new_vec = vec![];\n\n    for n in 0..offset_u {\n        new_vec.push(indexer.auction_caches[n])\n    }\n\n    new_vec.push(*auction_cache_info.key);\n\n    for n in offset_u..indexer.auction_caches.len() {\n        if new_vec.len() == MAX_INDEXED_ELEMENTS {\n            break;\n        }\n        new_vec.push(indexer.auction_caches[n])\n    }\n\n    indexer.auction_caches = new_vec;\n    indexer.serialize(&mut *store_index_info.data.borrow_mut())?;\n    Ok(())\n}",
        "callstack": "processor::set_store_index::process_set_store_index",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_1",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/deprecated_init_auction_manager_v1.rs",
        "code": "metaplex/program/src/processor/deprecated_init_auction_manager_v1.rs:20:1: 133:2 \n\tpub fn process_deprecated_init_auction_manager_v1(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    auction_manager_settings: AuctionManagerSettingsV1,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let auction_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let accept_payment_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let (bump_seed, vault, auction) = assert_common_checks(\n        program_id,\n        auction_manager_info,\n        vault_info,\n        auction_info,\n        store_info,\n        accept_payment_info,\n        authority_info,\n    )?;\n\n    if auction_manager_settings.winning_configs.len() != auction.num_possible_winners() as usize {\n        return Err(MetaplexError::WinnerAmountMismatch.into());\n    }\n\n    let mut winning_config_states: Vec<WinningConfigState> = vec![];\n    let mut winning_item_count: u8 = 0;\n    let mut any_with_more_than_one = false;\n    for winning_config in &auction_manager_settings.winning_configs {\n        let mut winning_config_state_items = vec![];\n        let mut safety_deposit_box_found_lookup: Vec<bool> = vec![];\n        for _ in 0..vault.token_type_count {\n            safety_deposit_box_found_lookup.push(false)\n        }\n        if winning_config.items.len() > 1 {\n            any_with_more_than_one = true;\n        }\n        for item in &winning_config.items {\n            // If this blows then they have more than 255 total items which is unacceptable in current impl\n            winning_item_count = winning_item_count\n                .checked_add(1)\n                .ok_or(MetaplexError::NumericalOverflowError)?;\n\n            // Check if index referenced exists\n            if item.safety_deposit_box_index as usize >= safety_deposit_box_found_lookup.len() {\n                return Err(MetaplexError::InvalidWinningConfigSafetyDepositIndex.into());\n            }\n\n            // Should never have same deposit index appear twice in one config.\n            let lookup = safety_deposit_box_found_lookup[item.safety_deposit_box_index as usize];\n            if lookup {\n                return Err(MetaplexError::DuplicateWinningConfigItemDetected.into());\n            } else {\n                safety_deposit_box_found_lookup[item.safety_deposit_box_index as usize] = true\n            }\n\n            if item.safety_deposit_box_index > vault.token_type_count {\n                return Err(MetaplexError::InvalidSafetyDepositBox.into());\n            }\n\n            winning_config_state_items.push(WinningConfigStateItem {\n                claimed: false,\n                primary_sale_happened: false,\n            })\n        }\n        winning_config_states.push(WinningConfigState {\n            items: winning_config_state_items,\n            money_pushed_to_accept_payment: false,\n        })\n    }\n\n    let authority_seeds = &[PREFIX.as_bytes(), &auction_info.key.as_ref(), &[bump_seed]];\n\n    create_or_allocate_account_raw(\n        *program_id,\n        auction_manager_info,\n        rent_info,\n        system_info,\n        payer_info,\n        MAX_AUCTION_MANAGER_V1_SIZE,\n        authority_seeds,\n    )?;\n\n    let mut auction_manager = AuctionManagerV1::from_account_info(auction_manager_info)?;\n\n    auction_manager.key = Key::AuctionManagerV1;\n    auction_manager.store = *store_info.key;\n    auction_manager.state.status = AuctionManagerStatus::Initialized;\n    auction_manager.settings = auction_manager_settings;\n    auction_manager.vault = *vault_info.key;\n    auction_manager.auction = *auction_info.key;\n    auction_manager.authority = *authority_info.key;\n    auction_manager.accept_payment = *accept_payment_info.key;\n    auction_manager.state.winning_config_items_validated = 0;\n    auction_manager.state.winning_config_states = winning_config_states;\n    auction_manager.straight_shot_optimization = !any_with_more_than_one;\n\n    if auction_manager.settings.participation_config.is_some() {\n        auction_manager.state.participation_state = Some(ParticipationStateV1 {\n            collected_to_accept_payment: 0,\n            validated: false,\n            primary_sale_happened: false,\n            printing_authorization_token_account: None,\n        })\n    }\n    auction_manager.serialize(&mut *auction_manager_info.data.borrow_mut())?;\n\n    Ok(())\n}",
        "callstack": "processor::deprecated_init_auction_manager_v1::process_deprecated_init_auction_manager_v1",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_2",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/init_auction_manager_v2.rs",
        "code": "metaplex/program/src/processor/init_auction_manager_v2.rs:97:1: 196:2 \n\tpub fn process_init_auction_manager_v2(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount_type: TupleNumericType,\n    length_type: TupleNumericType,\n    max_ranges: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let auction_token_tracker_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let auction_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let accept_payment_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    let (bump_seed, _vault, _auction) = assert_common_checks(\n        program_id,\n        auction_manager_info,\n        vault_info,\n        auction_info,\n        store_info,\n        accept_payment_info,\n        authority_info,\n    )?;\n\n    let authority_seeds = &[PREFIX.as_bytes(), &auction_info.key.as_ref(), &[bump_seed]];\n\n    create_or_allocate_account_raw(\n        *program_id,\n        auction_manager_info,\n        rent_info,\n        system_info,\n        payer_info,\n        MAX_AUCTION_MANAGER_V2_SIZE,\n        authority_seeds,\n    )?;\n\n    let mut auction_manager = AuctionManagerV2::from_account_info(auction_manager_info)?;\n\n    auction_manager.key = Key::AuctionManagerV2;\n    auction_manager.store = *store_info.key;\n    auction_manager.state.status = AuctionManagerStatus::Initialized;\n    auction_manager.vault = *vault_info.key;\n    auction_manager.auction = *auction_info.key;\n    auction_manager.authority = *authority_info.key;\n    auction_manager.accept_payment = *accept_payment_info.key;\n    auction_manager.state.safety_config_items_validated = 0;\n    auction_manager.state.bids_pushed_to_accept_payment = 0;\n\n    auction_manager.serialize(&mut *auction_manager_info.data.borrow_mut())?;\n\n    if !auction_token_tracker_info.data_is_empty() {\n        return Err(ProgramError::AccountAlreadyInitialized);\n    } else {\n        let token_bump = assert_derivation(\n            program_id,\n            auction_token_tracker_info,\n            &[\n                PREFIX.as_bytes(),\n                &program_id.as_ref(),\n                auction_manager_info.key.as_ref(),\n                TOTALS.as_bytes(),\n            ],\n        )?;\n\n        let token_type_tracker = AuctionWinnerTokenTypeTracker {\n            key: Key::AuctionWinnerTokenTypeTrackerV1,\n            amount_type,\n            length_type,\n            amount_ranges: vec![],\n        };\n\n        let token_seeds = &[\n            PREFIX.as_bytes(),\n            &program_id.as_ref(),\n            auction_manager_info.key.as_ref(),\n            TOTALS.as_bytes(),\n            &[token_bump],\n        ];\n\n        create_or_allocate_account_raw(\n            *program_id,\n            auction_token_tracker_info,\n            rent_info,\n            system_info,\n            payer_info,\n            token_type_tracker.created_size(max_ranges),\n            token_seeds,\n        )?;\n\n        token_type_tracker.save(&auction_token_tracker_info);\n    }\n\n    Ok(())\n}",
        "callstack": "processor::init_auction_manager_v2::process_init_auction_manager_v2",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_3",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/set_auction_cache.rs",
        "code": "metaplex/program/src/processor/set_auction_cache.rs:19:1: 143:2 \n\tpub fn process_set_auction_cache<'a>(\n    program_id: &'a Pubkey,\n    accounts: &'a [AccountInfo<'a>],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let auction_cache_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let auction_info = next_account_info(account_info_iter)?;\n    let safety_deposit_box_info = next_account_info(account_info_iter)?;\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let clock_info = next_account_info(account_info_iter)?;\n    let clock = Clock::from_account_info(clock_info)?;\n    let store = Store::from_account_info(store_info)?;\n    let _auction = AuctionData::from_account_info(auction_info)?;\n    let auction_manager = AuctionManagerV2::from_account_info(auction_manager_info)?;\n    let deposit_box = SafetyDepositBox::from_account_info(safety_deposit_box_info)?;\n\n    assert_signer(payer_info)?;\n\n    assert_owned_by(store_info, program_id)?;\n    assert_owned_by(auction_manager_info, program_id)?;\n    assert_owned_by(auction_info, &store.auction_program)?;\n    assert_owned_by(safety_deposit_box_info, &store.token_vault_program)?;\n\n    assert_derivation(\n        &store.auction_program,\n        auction_info,\n        &[\n            mpl_auction::PREFIX.as_bytes(),\n            store.auction_program.as_ref(),\n            deposit_box.vault.as_ref(),\n        ],\n    )?;\n\n    assert_derivation(\n        &store.token_vault_program,\n        safety_deposit_box_info,\n        &[\n            mpl_token_vault::state::PREFIX.as_bytes(),\n            auction_manager.vault.as_ref(),\n            deposit_box.token_mint.as_ref(),\n        ],\n    )?;\n\n    if deposit_box.vault != auction_manager.vault {\n        return Err(MetaplexError::InvalidSafetyDepositBox.into());\n    }\n\n    if system_info.key != &solana_program::system_program::id() {\n        return Err(MetaplexError::InvalidSystemProgram.into());\n    }\n\n    let bump = assert_derivation(\n        program_id,\n        auction_cache_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            auction_info.key.as_ref(),\n            CACHE.as_bytes(),\n        ],\n    )?;\n\n    let (metadata, _) = Pubkey::find_program_address(\n        &[\n            mpl_token_metadata::state::PREFIX.as_bytes(),\n            store.token_metadata_program.as_ref(),\n            deposit_box.token_mint.as_ref(),\n        ],\n        &store.token_metadata_program,\n    );\n\n    let mut cache: AuctionCache;\n    if auction_cache_info.data_is_empty() {\n        let signer_seeds = &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            auction_info.key.as_ref(),\n            CACHE.as_bytes(),\n            &[bump],\n        ];\n\n        create_or_allocate_account_raw(\n            *program_id,\n            auction_cache_info,\n            rent_info,\n            system_info,\n            payer_info,\n            MAX_AUCTION_CACHE_SIZE,\n            signer_seeds,\n        )?;\n        cache = AuctionCache::from_account_info(auction_cache_info)?;\n        cache.timestamp = clock.unix_timestamp;\n        cache.store = *store_info.key;\n    } else {\n        cache = AuctionCache::from_account_info(auction_cache_info)?;\n    }\n\n    assert_owned_by(auction_cache_info, program_id)?;\n\n    cache.key = Key::AuctionCacheV1;\n    cache.vault = auction_manager.vault;\n    cache.auction_manager = *auction_manager_info.key;\n    cache.auction = *auction_info.key;\n\n    if cache.metadata.len() == MAX_METADATA_PER_CACHE {\n        return Err(MetaplexError::MaxMetadataCacheSizeReached.into());\n    }\n    for key in &cache.metadata {\n        if key == &metadata {\n            return Err(MetaplexError::DuplicateKeyDetected.into());\n        }\n    }\n\n    cache.metadata.push(metadata);\n    cache.serialize(&mut *auction_cache_info.data.borrow_mut())?;\n\n    Ok(())\n}",
        "callstack": "processor::set_auction_cache::process_set_auction_cache",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_4",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/set_store.rs",
        "code": "metaplex/program/src/processor/set_store.rs:122:1: 193:2 \n\tpub fn process_set_store_v2<'a>(\n    program_id: &'a Pubkey,\n    accounts: &'a [AccountInfo<'a>],\n    public: bool,\n    settings_uri: Option<String>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let store_info = next_account_info(account_info_iter)?;\n    let store_config_info = next_account_info(account_info_iter)?;\n    let admin_wallet_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n    let token_vault_program_info = next_account_info(account_info_iter)?;\n    let token_metadata_program_info = next_account_info(account_info_iter)?;\n    let auction_program_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    let res = set_store_logic(\n        public,\n        program_id,\n        auction_program_info,\n        token_vault_program_info,\n        rent_info,\n        system_info,\n        token_metadata_program_info,\n        token_program_info,\n        store_info,\n        admin_wallet_info,\n        payer_info,\n    );\n    if res.is_err() {\n        return res;\n    }\n    if !store_config_info.data_is_empty() {\n        assert_owned_by(store_config_info, program_id)?;\n    }\n    let store_config_bump = assert_derivation(\n        program_id,\n        store_config_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            CONFIG.as_bytes(),\n            store_info.key.as_ref(),\n        ],\n    )?;\n\n    if store_config_info.data_is_empty() {\n        create_or_allocate_account_raw(\n            *program_id,\n            store_config_info,\n            rent_info,\n            system_info,\n            payer_info,\n            MAX_STORE_CONFIG_V1_SIZE,\n            &[\n                PREFIX.as_bytes(),\n                program_id.as_ref(),\n                CONFIG.as_bytes(),\n                store_info.key.as_ref(),\n                &[store_config_bump],\n            ],\n        )?;\n    }\n    let mut config = StoreConfig::from_account_info(store_config_info)?;\n    config.key = Key::StoreConfigV1;\n    config.settings_uri = settings_uri;\n    config.serialize(&mut *store_config_info.data.borrow_mut())?;\n    Ok(())\n}",
        "callstack": "processor::set_store::process_set_store_v2",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_5",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/deprecated_validate_participation.rs",
        "code": "metaplex/program/src/processor/deprecated_validate_participation.rs:24:1: 176:2 \n\tpub fn process_deprecated_validate_participation(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let open_edition_metadata_info = next_account_info(account_info_iter)?;\n    let open_master_edition_info = next_account_info(account_info_iter)?;\n    let printing_authorization_token_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let whitelisted_creator_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let safety_deposit_box_info = next_account_info(account_info_iter)?;\n    let safety_deposit_box_token_store_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let rent = &Rent::from_account_info(&rent_info)?;\n\n    let mut auction_manager = AuctionManagerV1::from_account_info(auction_manager_info)?;\n    let store = Store::from_account_info(store_info)?;\n    let vault = Vault::from_account_info(vault_info)?;\n    let safety_deposit_token_store: Account =\n        assert_initialized(safety_deposit_box_token_store_info)?;\n    let safety_deposit = SafetyDepositBox::from_account_info(safety_deposit_box_info)?;\n    let printing_token_account: Account =\n        assert_initialized(printing_authorization_token_account_info)?;\n    let open_edition_metadata = Metadata::from_account_info(open_edition_metadata_info)?;\n    let master_edition = MasterEditionV1::from_account_info(open_master_edition_info)?;\n\n    if vault.authority != *auction_manager_info.key {\n        return Err(MetaplexError::VaultAuthorityMismatch.into());\n    }\n\n    // top level authority and ownership check\n    assert_authority_correct(&auction_manager.authority, authority_info)?;\n    assert_owned_by(auction_manager_info, program_id)?;\n    assert_owned_by(open_edition_metadata_info, &store.token_metadata_program)?;\n    assert_owned_by(open_master_edition_info, &store.token_metadata_program)?;\n    assert_owned_by(\n        printing_authorization_token_account_info,\n        &store.token_program,\n    )?;\n    if *whitelisted_creator_info.key != solana_program::system_program::id() {\n        if whitelisted_creator_info.data_is_empty() {\n            return Err(MetaplexError::Uninitialized.into());\n        }\n        assert_owned_by(whitelisted_creator_info, program_id)?;\n    }\n    assert_owned_by(store_info, program_id)?;\n    assert_owned_by(safety_deposit_box_info, &store.token_vault_program)?;\n    assert_owned_by(safety_deposit_box_token_store_info, &store.token_program)?;\n    assert_owned_by(vault_info, &store.token_vault_program)?;\n    // is it the right vault, safety deposit, and token store?\n    assert_store_safety_vault_manager_match(\n        &auction_manager.vault,\n        &safety_deposit_box_info,\n        vault_info,\n        &store.token_vault_program,\n    )?;\n\n    // do the vault and store belong to this AM?\n    if auction_manager.store != *store_info.key {\n        return Err(MetaplexError::AuctionManagerStoreMismatch.into());\n    }\n\n    if auction_manager.vault != *vault_info.key {\n        return Err(MetaplexError::AuctionManagerVaultMismatch.into());\n    }\n    // Check creators\n    assert_at_least_one_creator_matches_or_store_public_and_all_verified(\n        program_id,\n        &auction_manager,\n        &open_edition_metadata,\n        whitelisted_creator_info,\n        store_info,\n    )?;\n\n    // Make sure master edition is the right master edition for this metadata given\n    assert_derivation(\n        &store.token_metadata_program,\n        open_master_edition_info,\n        &[\n            mpl_token_metadata::state::PREFIX.as_bytes(),\n            store.token_metadata_program.as_ref(),\n            &open_edition_metadata.mint.as_ref(),\n            mpl_token_metadata::state::EDITION.as_bytes(),\n        ],\n    )?;\n\n    // Assert the holding account for authorization tokens is rent filled, owned correctly, and ours\n    assert_owned_by(\n        printing_authorization_token_account_info,\n        &store.token_program,\n    )?;\n    assert_rent_exempt(rent, printing_authorization_token_account_info)?;\n\n    if printing_token_account.owner != *auction_manager_info.key {\n        return Err(MetaplexError::IncorrectOwner.into());\n    }\n\n    if printing_token_account.mint != master_edition.printing_mint {\n        return Err(MetaplexError::PrintingTokenAccountMintMismatch.into());\n    }\n\n    if printing_token_account.delegate != COption::None {\n        return Err(MetaplexError::DelegateShouldBeNone.into());\n    }\n\n    if printing_token_account.close_authority != COption::None {\n        return Err(MetaplexError::CloseAuthorityShouldBeNone.into());\n    }\n\n    if master_edition.max_supply.is_some() {\n        return Err(MetaplexError::CantUseLimitedSupplyEditionsWithOpenEditionAuction.into());\n    }\n\n    if master_edition.one_time_printing_authorization_mint != safety_deposit_token_store.mint {\n        return Err(MetaplexError::MasterEditionOneTimeAuthorizationMintMismatch.into());\n    }\n\n    if let Some(participation_config) = &auction_manager.settings.participation_config {\n        if participation_config.safety_deposit_box_index > vault.token_type_count {\n            return Err(MetaplexError::InvalidSafetyDepositBox.into());\n        }\n\n        if participation_config.safety_deposit_box_index != safety_deposit.order {\n            return Err(MetaplexError::SafetyDepositIndexMismatch.into());\n        }\n\n        if let Some(state) = auction_manager.state.participation_state {\n            if state.validated {\n                return Err(MetaplexError::AlreadyValidated.into());\n            }\n\n            auction_manager.state.participation_state = Some(ParticipationStateV1 {\n                collected_to_accept_payment: state.collected_to_accept_payment,\n                primary_sale_happened: open_edition_metadata.primary_sale_happened,\n                validated: true,\n                printing_authorization_token_account: Some(\n                    *printing_authorization_token_account_info.key,\n                ),\n            });\n        }\n\n        if auction_manager.settings.winning_configs.is_empty() {\n            auction_manager.state.status = AuctionManagerStatus::Validated;\n        }\n        auction_manager.serialize(&mut *auction_manager_info.data.borrow_mut())?;\n    }\n\n    Ok(())\n}",
        "callstack": "processor::deprecated_validate_participation::process_deprecated_validate_participation",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_6",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/deprecated_validate_safety_deposit_box_v1.rs",
        "code": "metaplex/program/src/processor/deprecated_validate_safety_deposit_box_v1.rs:67:1: 237:2 \n\tpub fn process_deprecated_validate_safety_deposit_box_v1<'a>(\n    program_id: &'a Pubkey,\n    accounts: &'a [AccountInfo<'a>],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let safety_deposit_validation_ticket_info = next_account_info(account_info_iter)?;\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let metadata_info = next_account_info(account_info_iter)?;\n    let original_authority_lookup_info = next_account_info(account_info_iter)?;\n    let whitelisted_creator_info = next_account_info(account_info_iter)?;\n    let auction_manager_store_info = next_account_info(account_info_iter)?;\n    let safety_deposit_info = next_account_info(account_info_iter)?;\n    let safety_deposit_token_store_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let edition_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let metadata_authority_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let token_metadata_program_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    if !safety_deposit_validation_ticket_info.data_is_empty() {\n        return Err(MetaplexError::AlreadyValidated.into());\n    }\n\n    let mut auction_manager = AuctionManagerV1::from_account_info(auction_manager_info)?;\n    let safety_deposit = SafetyDepositBox::from_account_info(safety_deposit_info)?;\n    let _safety_deposit_token_store: Account = assert_initialized(safety_deposit_token_store_info)?;\n    let metadata = Metadata::from_account_info(metadata_info)?;\n    let store = Store::from_account_info(auction_manager_store_info)?;\n    // Is it a real vault?\n    let vault = Vault::from_account_info(vault_info)?;\n\n    let mut total_amount_requested: u64 = 0;\n    // At this point we know we have at least one config and they may have different amounts but all\n    // point at the same safety deposit box and so have the same winning config type.\n    // We default to TokenOnlyTransfer but this will get set by the loop.\n    let mut winning_config_type: WinningConfigType = WinningConfigType::TokenOnlyTransfer;\n    let mut winning_config_items_validated: u8 = 0;\n    let mut all_winning_config_items: u8 = 0;\n\n    for i in 0..auction_manager.settings.winning_configs.len() {\n        let possible_config = &auction_manager.settings.winning_configs[i];\n\n        for j in 0..possible_config.items.len() {\n            let possible_item = &possible_config.items[j];\n            all_winning_config_items = all_winning_config_items\n                .checked_add(1)\n                .ok_or(MetaplexError::NumericalOverflowError)?;\n\n            if possible_item.safety_deposit_box_index == safety_deposit.order {\n                winning_config_type = possible_item.winning_config_type;\n\n                winning_config_items_validated = winning_config_items_validated\n                    .checked_add(1)\n                    .ok_or(MetaplexError::NumericalOverflowError)?;\n\n                // Build array to sum total amount\n                total_amount_requested = total_amount_requested\n                    .checked_add(possible_item.amount.into())\n                    .ok_or(MetaplexError::NumericalOverflowError)?;\n                // Record that primary sale happened at time of validation for later royalties reconcilation\n                auction_manager.state.winning_config_states[i].items[j].primary_sale_happened =\n                    metadata.primary_sale_happened;\n            }\n        }\n    }\n\n    if let Some(participation_config) = &auction_manager.settings.participation_config {\n        if participation_config.safety_deposit_box_index == safety_deposit.order {\n            // Really it's unknown how many prints will be made\n            // but we set it to 1 since that's how many master edition tokens are in there.\n            total_amount_requested = total_amount_requested\n                .checked_add(1)\n                .ok_or(MetaplexError::NumericalOverflowError)?;\n\n            // now that participation configs can be validated through normal safety deposit endpoints, need to flip this boolean\n            // here too, until we can deprecate it later.\n            if let Some(state) = &auction_manager.state.participation_state {\n                auction_manager.state.participation_state = Some(ParticipationStateV1 {\n                    collected_to_accept_payment: state.collected_to_accept_payment,\n                    primary_sale_happened: state.primary_sale_happened,\n                    validated: true,\n                    printing_authorization_token_account: state\n                        .printing_authorization_token_account,\n                })\n            }\n        }\n    }\n\n    if total_amount_requested == 0 {\n        return Err(MetaplexError::SafetyDepositBoxNotUsedInAuction.into());\n    }\n\n    assert_common_checks(CommonCheckArgs {\n        program_id,\n        auction_manager_info,\n        metadata_info,\n        original_authority_lookup_info,\n        whitelisted_creator_info,\n        safety_deposit_info,\n        safety_deposit_token_store_info,\n        edition_info,\n        vault_info,\n        mint_info,\n        token_metadata_program_info,\n        auction_manager_store_info,\n        authority_info,\n        store: &store,\n        auction_manager: &auction_manager,\n        metadata: &metadata,\n        safety_deposit: &safety_deposit,\n        vault: &vault,\n        winning_config_type: &winning_config_type,\n    })?;\n\n    assert_supply_logic_check(SupplyLogicCheckArgs {\n        program_id,\n        auction_manager_info,\n        metadata_info,\n        edition_info,\n        metadata_authority_info,\n        original_authority_lookup_info,\n        rent_info,\n        system_info,\n        payer_info,\n        token_metadata_program_info,\n        auction_manager: &auction_manager,\n        winning_config_type: &winning_config_type,\n        metadata: &metadata,\n        safety_deposit: &safety_deposit,\n        store: &store,\n        safety_deposit_token_store_info,\n        total_amount_requested,\n    })?;\n\n    auction_manager.state.winning_config_items_validated = match auction_manager\n        .state\n        .winning_config_items_validated\n        .checked_add(winning_config_items_validated)\n    {\n        Some(val) => val,\n        None => return Err(MetaplexError::NumericalOverflowError.into()),\n    };\n\n    if auction_manager.state.winning_config_items_validated == all_winning_config_items {\n        let mut participation_okay = true;\n        if let Some(state) = &auction_manager.state.participation_state {\n            participation_okay = state.validated\n        }\n        if participation_okay {\n            auction_manager.state.status = AuctionManagerStatus::Validated\n        }\n    }\n\n    auction_manager.serialize(&mut *auction_manager_info.data.borrow_mut())?;\n\n    make_safety_deposit_validation(\n        program_id,\n        auction_manager_info,\n        safety_deposit_info,\n        safety_deposit_validation_ticket_info,\n        payer_info,\n        rent_info,\n        system_info,\n    )?;\n\n    Ok(())\n}",
        "callstack": "processor::deprecated_validate_safety_deposit_box_v1::process_deprecated_validate_safety_deposit_box_v1",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_7",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/empty_payment_account.rs",
        "code": "metaplex/program/src/processor/empty_payment_account.rs:212:1: 458:2 \n\tpub fn process_empty_payment_account(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    args: EmptyPaymentAccountArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let accept_payment_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let auction_manager_info = next_account_info(account_info_iter)?;\n    let payout_ticket_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let metadata_info = next_account_info(account_info_iter)?;\n    let master_edition_info = next_account_info(account_info_iter)?;\n    let safety_deposit_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let auction_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let auction_token_tracker_info = next_account_info(account_info_iter).ok();\n    let safety_deposit_config_info = next_account_info(account_info_iter).ok();\n\n    if let Some(tracker_info) = auction_token_tracker_info {\n        assert_derivation(\n            program_id,\n            tracker_info,\n            &[\n                PREFIX.as_bytes(),\n                &program_id.as_ref(),\n                auction_manager_info.key.as_ref(),\n                TOTALS.as_bytes(),\n            ],\n        )?;\n    }\n\n    let rent = &Rent::from_account_info(&rent_info)?;\n\n    let auction_manager = get_auction_manager(auction_manager_info)?;\n    let store = Store::from_account_info(store_info)?;\n    let safety_deposit = SafetyDepositBox::from_account_info(safety_deposit_info)?;\n    let metadata = Metadata::from_account_info(metadata_info)?;\n    let auction = AuctionData::from_account_info(auction_info)?;\n    let destination: Account = assert_initialized(destination_info)?;\n    let accept_payment: Account = assert_initialized(accept_payment_info)?;\n\n    if auction_manager.store() != *store_info.key {\n        return Err(MetaplexError::AuctionManagerStoreMismatch.into());\n    }\n\n    msg!(\n        \"At this point, accept payment has {:?} in it\",\n        accept_payment.amount\n    );\n\n    // Before continuing further, assert all bid monies have been pushed to the main escrow\n    // account so that we have a complete (less the unredeemed participation nft bids) accounting\n    // to work with\n    auction_manager.assert_all_bids_claimed(&auction)?;\n\n    if *token_program_info.key != store.token_program {\n        return Err(MetaplexError::AuctionManagerTokenProgramMismatch.into());\n    }\n\n    assert_owned_by(auction_manager_info, program_id)?;\n    if !payout_ticket_info.data_is_empty() {\n        assert_owned_by(payout_ticket_info, program_id)?;\n    }\n    assert_owned_by(destination_info, token_program_info.key)?;\n    assert_owned_by(accept_payment_info, token_program_info.key)?;\n    assert_owned_by(metadata_info, &store.token_metadata_program)?;\n    if *master_edition_info.key != solana_program::system_program::id() {\n        assert_owned_by(master_edition_info, &store.token_metadata_program)?;\n    }\n    assert_owned_by(safety_deposit_info, &store.token_vault_program)?;\n    assert_owned_by(store_info, program_id)?;\n    assert_owned_by(vault_info, &store.token_vault_program)?;\n    assert_owned_by(auction_info, &store.auction_program)?;\n    assert_rent_exempt(rent, destination_info)?;\n\n    // Assert the winning config points to the safety deposit you sent up\n    auction_manager.assert_winning_config_safety_deposit_validity(\n        &safety_deposit,\n        args.winning_config_index,\n        args.winning_config_item_index,\n    )?;\n\n    assert_safety_deposit_config_valid(\n        program_id,\n        auction_manager_info,\n        safety_deposit_info,\n        safety_deposit_config_info,\n        &auction_manager.key(),\n    )?;\n\n    // assert the destination account matches the ownership expected to creator or auction manager authority\n    // given in the argument's creator index\n    assert_destination_ownership_validity(\n        &auction_manager,\n        &metadata,\n        destination_info,\n        &destination,\n        &store,\n        args.creator_index,\n    )?;\n\n    // further assert that the vault and safety deposit are correctly matched to the auction manager\n    if auction_manager.vault() != *vault_info.key {\n        return Err(MetaplexError::AuctionManagerVaultMismatch.into());\n    }\n\n    if auction_manager.auction() != *auction_info.key {\n        return Err(MetaplexError::AuctionManagerAuctionMismatch.into());\n    }\n\n    if safety_deposit.vault != *vault_info.key {\n        return Err(MetaplexError::SafetyDepositBoxVaultMismatch.into());\n    }\n\n    // assert that the metadata sent up is the metadata in the safety deposit\n    if metadata.mint != safety_deposit.token_mint {\n        if master_edition_info.data.borrow()[0]\n            == mpl_token_metadata::state::Key::MasterEditionV1 as u8\n        {\n            // Could be a limited edition, in which case printing tokens or auth tokens were offered, not the original.\n            let master_edition: MasterEditionV1 =\n                MasterEditionV1::from_account_info(master_edition_info)?;\n            if master_edition.printing_mint != safety_deposit.token_mint\n                && master_edition.one_time_printing_authorization_mint != safety_deposit.token_mint\n            {\n                return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n            }\n        } else {\n            return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n        }\n    }\n\n    // make sure the accept payment account is right\n    if auction_manager.accept_payment() != *accept_payment_info.key {\n        return Err(MetaplexError::AcceptPaymentMismatch.into());\n    }\n\n    if destination.mint != accept_payment.mint {\n        return Err(MetaplexError::AcceptPaymentMintMismatch.into());\n    }\n\n    let winning_config_index_key: String = match args.winning_config_index {\n        Some(val) => val.to_string(),\n        None => \"participation\".to_owned(),\n    };\n\n    let winning_config_item_index_key: String = match args.winning_config_item_index {\n        Some(val) => val.to_string(),\n        None => \"0\".to_owned(),\n    };\n\n    let creator_index_key: String = match args.creator_index {\n        Some(val) => val.to_string(),\n        None => \"auctioneer\".to_owned(),\n    };\n\n    let payout_bump = assert_derivation(\n        program_id,\n        payout_ticket_info,\n        &[\n            PREFIX.as_bytes(),\n            auction_manager_info.key.as_ref(),\n            winning_config_index_key.as_bytes(),\n            winning_config_item_index_key.as_bytes(),\n            creator_index_key.as_bytes(),\n            &safety_deposit_info.key.as_ref(),\n            &destination.owner.as_ref(),\n        ],\n    )?;\n\n    let payout_seeds = &[\n        PREFIX.as_bytes(),\n        auction_manager_info.key.as_ref(),\n        winning_config_index_key.as_bytes(),\n        winning_config_item_index_key.as_bytes(),\n        creator_index_key.as_bytes(),\n        &safety_deposit_info.key.as_ref(),\n        &destination.owner.as_ref(),\n        &[payout_bump],\n    ];\n\n    if payout_ticket_info.data_is_empty() {\n        create_or_allocate_account_raw(\n            *program_id,\n            payout_ticket_info,\n            rent_info,\n            system_info,\n            payer_info,\n            MAX_PAYOUT_TICKET_SIZE,\n            payout_seeds,\n        )?;\n    }\n\n    let mut payout_ticket = PayoutTicket::from_account_info(payout_ticket_info)?;\n    payout_ticket.recipient = destination.owner;\n    payout_ticket.key = Key::PayoutTicketV1;\n\n    let amount = calculate_owed_amount(\n        auction_token_tracker_info,\n        safety_deposit_config_info,\n        &auction_manager,\n        &auction,\n        &metadata,\n        &args.winning_config_index,\n        &args.winning_config_item_index,\n        &args.creator_index,\n    )?;\n\n    let final_amount = amount\n        .checked_sub(payout_ticket.amount_paid)\n        .ok_or(MetaplexError::NumericalOverflowError)?;\n\n    if final_amount > 0 {\n        payout_ticket.amount_paid = payout_ticket\n            .amount_paid\n            .checked_add(final_amount)\n            .ok_or(MetaplexError::NumericalOverflowError)?;\n\n        let auction_key = auction_manager.auction();\n\n        let bump_seed = assert_derivation(\n            program_id,\n            auction_manager_info,\n            &[PREFIX.as_bytes(), auction_key.as_ref()],\n        )?;\n\n        let authority_seeds = &[PREFIX.as_bytes(), auction_key.as_ref(), &[bump_seed]];\n\n        spl_token_transfer(\n            accept_payment_info.clone(),\n            destination_info.clone(),\n            final_amount,\n            auction_manager_info.clone(),\n            authority_seeds,\n            token_program_info.clone(),\n        )?;\n    }\n\n    payout_ticket.serialize(&mut *payout_ticket_info.data.borrow_mut())?;\n\n    Ok(())\n}",
        "callstack": "processor::empty_payment_account::process_empty_payment_account",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_8",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/validate_safety_deposit_box_v2.rs",
        "code": "metaplex/program/src/processor/validate_safety_deposit_box_v2.rs:205:1: 381:2 \n\tpub fn assert_supply_logic_check(args: SupplyLogicCheckArgs) -> ProgramResult {\n    let SupplyLogicCheckArgs {\n        program_id,\n        auction_manager_info,\n        metadata_info,\n        edition_info,\n        metadata_authority_info,\n        original_authority_lookup_info,\n        rent_info,\n        system_info,\n        payer_info,\n        token_metadata_program_info,\n        auction_manager,\n        winning_config_type,\n        metadata,\n        safety_deposit,\n        store,\n        safety_deposit_token_store_info,\n        total_amount_requested,\n    } = args;\n\n    let safety_deposit_token_store: Account = assert_initialized(safety_deposit_token_store_info)?;\n\n    let edition_seeds = &[\n        mpl_token_metadata::state::PREFIX.as_bytes(),\n        store.token_metadata_program.as_ref(),\n        &metadata.mint.as_ref(),\n        mpl_token_metadata::state::EDITION.as_bytes(),\n    ];\n\n    let (edition_key, _) =\n        Pubkey::find_program_address(edition_seeds, &store.token_metadata_program);\n\n    let auction_key = auction_manager.auction();\n    let seeds = &[PREFIX.as_bytes(), auction_key.as_ref()];\n    let (_, bump_seed) = Pubkey::find_program_address(seeds, &program_id);\n    let authority_seeds = &[PREFIX.as_bytes(), auction_key.as_ref(), &[bump_seed]];\n    // Supply logic check\n    match winning_config_type {\n        WinningConfigType::FullRightsTransfer => {\n            assert_update_authority_is_correct(&metadata, metadata_authority_info)?;\n\n            if safety_deposit.token_mint != metadata.mint {\n                return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n            }\n            if edition_key != *edition_info.key {\n                return Err(MetaplexError::InvalidEditionAddress.into());\n            }\n\n            if safety_deposit_token_store.amount != 1 {\n                return Err(MetaplexError::StoreIsEmpty.into());\n            }\n\n            if total_amount_requested != 1 {\n                return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n            }\n\n            let auction_key = auction_manager.auction();\n\n            let original_authority_lookup_seeds = &[\n                PREFIX.as_bytes(),\n                auction_key.as_ref(),\n                metadata_info.key.as_ref(),\n            ];\n\n            let (expected_key, original_bump_seed) =\n                Pubkey::find_program_address(original_authority_lookup_seeds, &program_id);\n            let original_authority_seeds = &[\n                PREFIX.as_bytes(),\n                auction_key.as_ref(),\n                metadata_info.key.as_ref(),\n                &[original_bump_seed],\n            ];\n\n            if expected_key != *original_authority_lookup_info.key {\n                return Err(MetaplexError::OriginalAuthorityLookupKeyMismatch.into());\n            }\n\n            // We may need to transfer authority back, or to the new owner, so we need to keep track\n            // of original ownership\n            create_or_allocate_account_raw(\n                *program_id,\n                original_authority_lookup_info,\n                rent_info,\n                system_info,\n                payer_info,\n                MAX_AUTHORITY_LOOKUP_SIZE,\n                original_authority_seeds,\n            )?;\n\n            let mut original_authority_lookup =\n                OriginalAuthorityLookup::from_account_info(original_authority_lookup_info)?;\n            original_authority_lookup.key = Key::OriginalAuthorityLookupV1;\n\n            original_authority_lookup.original_authority = *metadata_authority_info.key;\n\n            transfer_metadata_ownership(\n                token_metadata_program_info.clone(),\n                metadata_info.clone(),\n                metadata_authority_info.clone(),\n                auction_manager_info.clone(),\n                authority_seeds,\n            )?;\n\n            original_authority_lookup\n                .serialize(&mut *original_authority_lookup_info.data.borrow_mut())?;\n        }\n        WinningConfigType::TokenOnlyTransfer => {\n            if safety_deposit.token_mint != metadata.mint {\n                return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n            }\n            if safety_deposit_token_store.amount < total_amount_requested {\n                return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n            }\n        }\n        WinningConfigType::PrintingV1 => {\n            if edition_key != *edition_info.key {\n                return Err(MetaplexError::InvalidEditionAddress.into());\n            }\n            let master_edition = MasterEditionV1::from_account_info(edition_info)?;\n            if safety_deposit.token_mint != master_edition.printing_mint {\n                return Err(MetaplexError::SafetyDepositBoxMasterMintMismatch.into());\n            }\n\n            if safety_deposit_token_store.amount != total_amount_requested {\n                return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n            }\n        }\n        WinningConfigType::PrintingV2 => {\n            if edition_key != *edition_info.key {\n                return Err(MetaplexError::InvalidEditionAddress.into());\n            }\n            let master_edition = MasterEditionV2::from_account_info(edition_info)?;\n            if safety_deposit.token_mint != metadata.mint {\n                return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n            }\n\n            if safety_deposit_token_store.amount != 1 {\n                return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n            }\n\n            if let Some(max) = master_edition.max_supply {\n                let amount_available = max\n                    .checked_sub(master_edition.supply)\n                    .ok_or(MetaplexError::NumericalOverflowError)?;\n                if amount_available < total_amount_requested {\n                    return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n                }\n            }\n        }\n        WinningConfigType::Participation => {\n            // Impossible to use a MEV1 through this avenue of participation...no one time auth token allowed here...\n            // If you wish to use those, you must use the AuctionManagerV1 pathway which allows use of the older endpoints,\n            // which will classify Participation as a PrintingV2 if it's an MEv2 or use the validate_participation endpoint\n            // if it's an MEv1.\n            if edition_key != *edition_info.key {\n                return Err(MetaplexError::InvalidEditionAddress.into());\n            }\n            let master_edition = MasterEditionV2::from_account_info(edition_info)?;\n            if safety_deposit.token_mint != metadata.mint {\n                return Err(MetaplexError::SafetyDepositBoxMetadataMismatch.into());\n            }\n\n            if safety_deposit_token_store.amount != 1 {\n                return Err(MetaplexError::NotEnoughTokensToSupplyWinners.into());\n            }\n\n            if master_edition.max_supply.is_some() {\n                return Err(\n                    MetaplexError::CantUseLimitedSupplyEditionsWithOpenEditionAuction.into(),\n                );\n            }\n        }\n    }\n\n    Ok(())\n}",
        "callstack": "processor::validate_safety_deposit_box_v2::assert_supply_logic_check",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      },
      {
        "type": "MissingCheckerCve",
        "id": "CHK_CVE_9",
        "title": "is_owner",
        "category": "Missing Owner Check",
        "severity": "Critical",
        "location": "metaplex/program/src/processor/set_whitelisted_creator.rs",
        "code": "metaplex/program/src/processor/set_whitelisted_creator.rs:16:1: 84:2 \n\tpub fn process_set_whitelisted_creator<'a>(\n    program_id: &'a Pubkey,\n    accounts: &'a [AccountInfo<'a>],\n    activated: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n\n    let whitelisted_creator_info = next_account_info(account_info_iter)?;\n    let admin_wallet_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n    let creator_info = next_account_info(account_info_iter)?;\n    let store_info = next_account_info(account_info_iter)?;\n    let system_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    assert_signer(payer_info)?;\n    assert_signer(admin_wallet_info)?;\n    if !whitelisted_creator_info.data_is_empty() {\n        assert_owned_by(whitelisted_creator_info, program_id)?;\n    }\n    assert_owned_by(store_info, program_id)?;\n\n    assert_derivation(\n        program_id,\n        store_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            admin_wallet_info.key.as_ref(),\n        ],\n    )?;\n\n    let creator_bump = assert_derivation(\n        program_id,\n        whitelisted_creator_info,\n        &[\n            PREFIX.as_bytes(),\n            program_id.as_ref(),\n            store_info.key.as_ref(),\n            creator_info.key.as_ref(),\n        ],\n    )?;\n\n    if whitelisted_creator_info.data_is_empty() {\n        create_or_allocate_account_raw(\n            *program_id,\n            whitelisted_creator_info,\n            rent_info,\n            system_info,\n            payer_info,\n            MAX_WHITELISTED_CREATOR_SIZE,\n            &[\n                PREFIX.as_bytes(),\n                program_id.as_ref(),\n                store_info.key.as_ref(),\n                creator_info.key.as_ref(),\n                &[creator_bump],\n            ],\n        )?;\n    }\n\n    let mut whitelisted_creator = WhitelistedCreator::from_account_info(whitelisted_creator_info)?;\n    whitelisted_creator.key = Key::WhitelistedCreatorV1;\n    whitelisted_creator.address = *creator_info.key;\n    whitelisted_creator.activated = activated;\n\n    whitelisted_creator.serialize(&mut *whitelisted_creator_info.data.borrow_mut())?;\n    Ok(())\n}",
        "callstack": "processor::set_whitelisted_creator::process_set_whitelisted_creator",
        "status": "UnResolved",
        "description": "Description of the bug here.",
        "link": "GitHub Link to be added.",
        "alleviation": "Some alleviation steps here."
      }
    ]
  }